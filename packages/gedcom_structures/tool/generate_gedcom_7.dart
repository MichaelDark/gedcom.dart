// https://github.com/FamilySearch/GEDCOM/tree/main/extracted-files/tags
// https://raw.githubusercontent.com/user/repository/branch/filename

import 'dart:io';

import 'package:code_builder/code_builder.dart';
import 'package:collection/collection.dart';
import 'package:dart_style/dart_style.dart';
import 'package:path/path.dart' as p;
import 'package:recase/recase.dart';
import 'package:yaml_codec/yaml_codec.dart';

const registriesUrl = 'https://github.com/FamilySearch/GEDCOM-registries.git';

const baseClassName = 'Gedcom7Structure';
const baseClassFile = 'gedcom_7_structure.dart';

final tagsConstantsFilePath = 'lib/src/gedcom_7/gedcom_7_tags.generated.dart';
final structureFilePath = 'lib/src/gedcom_7/gedcom_7_structures.generated.dart';

/// Generate Dart classes for GEDCOM 7 spec
/// based on the [registriesUrl] GitHub repository.
void main() async {
  final tmpDir = Directory('tool/tmp');

  try {
    tmpDir.createSync(recursive: true);

    await _cloneAndGenerate(tmpDir);
  } finally {
    tmpDir.deleteSync(recursive: true);
  }
}

Future<void> _cloneAndGenerate(Directory tmpDir) async {
  final gedcomRegistries = _cloneGedcomRegistries(tmpDir);

  // for (final entry in specification.entries) {
  //   print(['${entry.uri}', '${entry.type}', '${entry.standardTag}']
  //       .join(' '));
  // }

  final tagsConstantsClass = _buildTagsConstantsClass(gedcomRegistries);
  final tagsConstantsLib = Library((l) {
    l.ignoreForFile.add('constant_identifier_names');
    l.body.add(tagsConstantsClass);
  });
  final tagsConstantsText = _specToString(tagsConstantsLib);
  final tagsConstantsFile = File(tagsConstantsFilePath);
  tagsConstantsFile.createSync();
  tagsConstantsFile.writeAsStringSync(tagsConstantsText);

  final structuresSpecs = _buildStructureClasses(gedcomRegistries);
  final structuresLib = Library((l) {
    l.directives.add(Directive.partOf(baseClassFile));
    l.body.addAll(structuresSpecs);
  });
  final structuresText = _specToString(structuresLib);
  final structuresFile = File(structureFilePath);
  structuresFile.createSync();
  structuresFile.writeAsStringSync(structuresText);
}

GedcomRegistries _cloneGedcomRegistries(Directory tmpDir) {
  Process.runSync(
    'git',
    ['clone', registriesUrl, '-b', 'main'],
    workingDirectory: tmpDir.path,
  );

  final structuresDir = Directory(
    p.join(tmpDir.path, 'GEDCOM-registries/structure/standard'),
  );
  final structures = structuresDir
      .listSync()
      .whereType<File>()
      .map((file) => yaml.decode(file.readAsStringSync()) as Map);

  return GedcomRegistries(structures);
}

String _specToString(Spec spec) {
  final emitter = DartEmitter();
  final raw = spec.accept(emitter).toString();
  final formatter = DartFormatter(pageWidth: 80);
  final output = formatter.format(raw);
  return output;
}

Class _buildTagsConstantsClass(GedcomRegistries specification) {
  final sortedStructureSpecs = specification.structureSpecs
      .sortedBy((structureSpec) => structureSpec.constantName);

  return Class((c) {
    c.docs.add('/// Autogenerated.');
    c.name = 'Gedcom7Tags';
    c.constructors.add(Constructor((c) {
      c.name = '_';
      c.constant = true;
    }));

    for (final structureSpec in sortedStructureSpecs) {
      c.fields.add(Field((f) {
        f.static = true;
        f.modifier = FieldModifier.constant;
        f.docs.addAll(
          [
            structureSpec.uri.toString(),
            '',
            ...structureSpec.specification.expand(
              (line) => (line as String).split('\n'),
            ),
          ].map((doc) => '/// $doc'),
        );
        f.name = structureSpec.constantName;
        f.assignment = literalString(structureSpec.standardTag).code;
      }));
    }
  });
}

List<Spec> _buildStructureClasses(GedcomRegistries specification) {
  final structuresSortedGrouped = specification.structureSpecs
      .where((entry) => entry.type == 'structure')
      .sortedBy((entry) => entry.constantName)
      .groupListsBy((entry) => entry.standardTag)
      .entries
      .map((entry) => entry.value);

  return [
    _buildStructureParserMethod(structuresSortedGrouped),
    _buildStructureClass(
      'UnknownStructure',
      classDocs: ['Structure with unknown tag'],
    ),
    for (final structures in structuresSortedGrouped) ...[
      _buildStructureClass(
        structures.first.className,
        classDocs: [
          'See:',
          for (final structure in structures)
            ' - [Gedcom7Tags.${structure.constantName}]',
        ],
        substructures: structures
            .expand((entry) => entry.substructures)
            .map((substructure) => substructure)
            .groupListsBy((substr) => substr.structureSpec.getterName)
            .values
            .map((substrs) => substrs.first),
      )
    ],
  ];
}

Method _buildStructureParserMethod(
  Iterable<List<GedcomStructureSpec>> structuresSortedGrouped,
) {
  return Method((m) {
    m.name = '_parseStructure';
    m.returns = refer(baseClassName);
    m.lambda = false;
    m.optionalParameters.addAll(
      {
        'level': 'int',
        'tag': 'String',
        'xref': 'String?',
        'lineVal': 'String?',
        'substructures': 'Iterable<GedcomStructure>?',
      }.entries.map(
            (entry) => Parameter(
              (p) {
                p.name = entry.key;
                p.named = true;
                p.required = true;
                p.type = refer(entry.value);
              },
            ),
          ),
    );

    final buffer = StringBuffer();
    buffer.write('return switch (tag) {');
    for (final [structure, ...] in structuresSortedGrouped) {
      buffer.write('\'${structure.standardTag}\'');
      buffer.write(' => ');
      buffer.write('${structure.className}._,');
    }
    buffer.write('_ => UnknownStructure._,');
    buffer.write(
      '''
}(
  level: level,
  tag: tag,
  xref: xref,
  lineVal: lineVal,
  substructures: substructures?.map($baseClassName.from),
);''',
    );
    m.body = Code(buffer.toString());
  });
}

Class _buildStructureClass(
  String name, {
  Iterable<String> classDocs = const Iterable.empty(),
  Iterable<GedcomStructureSpecSubstructure> substructures = const [],
}) {
  return Class((c) {
    c.docs.addAll(classDocs.map((doc) => '/// $doc'));
    c.name = name;
    c.extend = refer(baseClassName);
    c.constructors.add(Constructor((constructor) {
      constructor.name = '_';
      constructor.optionalParameters.addAll(
        [
          'level',
          'tag',
          'xref',
          'lineVal',
          'substructures',
        ].map(
          (name) => Parameter((p) {
            p.name = name;
            p.toSuper = true;
            p.named = true;
            p.required = true;
          }),
        ),
      );
      constructor.initializers.add(Code('super._()'));
    }));

    for (final substr in substructures) {
      final spec = substr.structureSpec;

      Reference returns;
      String name;
      Code body;
      if (substr.isMany) {
        returns = refer('Iterable<${spec.className}>');
        name = '${spec.getterName}List';
        body = Code('getAll<${spec.className}>()');
      } else {
        returns = refer('${spec.className}?');
        name = spec.getterName;
        body = Code('getOrNull<${spec.className}>()');
      }

      c.methods.add(Method((m) {
        m.docs.add('/// ${substr.uri} [Gedcom7Tags.${spec.constantName}]');
        m.returns = returns;
        m.name = name;
        m.body = body;
        m.type = MethodType.getter;
        m.lambda = true;
      }));
    }
  });
}

class GedcomRegistries {
  final List<GedcomStructureSpec> structureSpecs = [];
  final Map<Uri, GedcomStructureSpec> _structureSpecUriMap = {};

  GedcomRegistries(Iterable<Map> structures) {
    for (final structure in structures) {
      final spec = GedcomStructureSpec(this, structure);
      structureSpecs.add(spec);
      _structureSpecUriMap[spec.uri] = spec;
    }
  }
}

class GedcomStructureSpec {
  final GedcomRegistries _registries;
  final Map yamlMap;

  GedcomStructureSpec(this._registries, this.yamlMap);

  Uri get uri => Uri.parse(yamlMap['uri']);

  String get uriName => uri.pathSegments.last;

  String get type => yamlMap['type'];
  String get label => yamlMap['label'];
  String get standardTag => yamlMap['standard tag'];
  Iterable get specification => yamlMap['specification'];

  Iterable<GedcomStructureSpecSubstructure> get substructures =>
      (yamlMap['substructures'] as Map).entries.map(
        (entry) {
          final substructureUri = Uri.parse(entry.key);

          return GedcomStructureSpecSubstructure(
            uri: substructureUri,
            structureSpec: _registries._structureSpecUriMap[substructureUri]!,
            cardinality: entry.value,
          );
        },
      );

  String get constantName => uriName.replaceAll('-', '_').toUpperCase();
  String get className {
    final labelRepl = label
        .replaceAll(',', '_')
        .replaceAll(' ', '_')
        .replaceAll(',', '_')
        .replaceAll(RegExp('_+'), '_')
        .pascalCase;
    return switch (labelRepl) {
      'Gedcom' => '\$GedcomStructure',
      _ => '${labelRepl}Structure',
    };
  }

  String get getterName => switch (standardTag.camelCase) {
        'level' => '\$level',
        'tag' => '\$tag',
        'xref' => '\$xref',
        'lineVal' => '\$lineVal',
        'substructures' => '\$substructures',
        String other => other,
      };
}

class GedcomStructureSpecSubstructure {
  final Uri uri;
  final GedcomStructureSpec structureSpec;
  final String cardinality;

  GedcomStructureSpecSubstructure({
    required this.uri,
    required this.structureSpec,
    required this.cardinality,
  });

  bool get isMany => cardinality.endsWith('M}');
}
